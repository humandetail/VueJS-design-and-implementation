# 非原始值的响应式方案

## 理解 Proxy 和 Reflect

什么是 Proxy？简单地说，使用 Proxy 可以创建一个代理对象。它能够实现对**其他对象（也就是非原始值）**的代理。

代理指的是对一个对象的**基本语义**的代理；Proxy 允许我们拦截并重新定义对一个对象的基本操作。

什么是基本语义？给出一个对象 obj，可以对它进行一些操作，例如读取属性值、设置属性值：

```js
obj.foo // 读取属性 foo 的值
obj.foo++ // 读取和设置属性 foo 的值
```

这种就属于基本语义的操作，即基本操作。既然是基本操作，那么它就可以使用 Proxy 拦截：

```js
const p = new Proxy(obj, {
  // 拦截读取属性操作
	get () { /* ... */ },
  // 拦截设置属性操作
  set () { /* ... */ }
})
```

在 JavaScript 中，万物皆对象。例如一个函数也是一个对象，所以调用函数也是对一个对象的基本操作：

```js
const fn = name => console.log(`我是：${name}`)
fn() // 调用函数是对对象的基本操作
```

因此我们可以用 Proxy 来拦截函数的调用操作，这里使用 apply 拦截函数的调用：

```js
const p2 = new Proxy(fn, {
  apply (traget, thisArg, argArray) {
    target.call(thisArg, ...argArray)
  }
})

p2('zhangsan') // 输出：'我是：zhangsan'
```

上面的两个例子说明了什么是基本操作。Proxy 只能拦截对一个对象的基本操作。那么什么是非基本操作呢？其实调用对象下的方法就是一个典型的非基本操作，我们称它为**复合操作：**

```js
obj.fn()
```

它由两个基本语义组成：get 和 apply。先通过 get 操作得到 obj.fn 属性，然后再通过  apply 调用 。

理解了 Proxy，我们再讨论 Reflect。Reflect 是一个全局对象，其下有许多方法，例如：

```js
Reflect.get()
Reflect.set()
Reflect.apply()
// ...
```

任何在 Proxy 的拦截器中能够找到的方法，都能够在 Reflect 中找到同名函数，那么这些函数的作用是什么呢？拿 Reflect.get 函数来说，它的功能就是提供了访问一个对象属性的默认行为：

```js
const obj = { foo: 1 }

console.log(obj.foo) // 1
console.log(Reflect.get(obj, 'foo')) // 1
```

这两种操作是等价的。Reflect 还能接收第三个参数，即指定接收者 receiver，可以理解为函数调用过程中的 this，例如：

```js
const obj = { foo: 1 }
console.log(Reflect.get(obj, 'foo', { foo: 2 })) // 2
```

这上面的代码中，我们指定了 `{ foo: 2 }` 这个对象为 receiver，这时读取到的值是 receiver 对象的 foo 属性值。

实际上，Reflect 上面的方法还有很多其他方面的意义，但这里只关心 receiver 这一点，因为它与响应式数据的实现密切相关。为了说明问题，我们回顾一下之前实现的响应式的代码：

```js
const data = { foo: 1 }

// 对原始数据进行代理
const obj = new Proxy(data, {
  // 拦截读取操作
  get (target, key) {
    track(target, key)

    // 返回属性值
    return target[key]
  },

  // 拦截设置操作
  set (target, key, value) {
    // 设置属性值
    target[key] = value
    
    trigger(target, key)

    // 返回 true 表示设置操作成功
    return true
  }
})
```

我们之前都是利用原始对象 target 来完成对属性的读取和设置操作的，其中原始对象 target 就是上述代码中的 data 对象。

那么这段代码有什么问题呢？我们借助 effect 让问题暴露出来。

首先我们修改一下 data 对象，为它添加 bar 属性：

```js
const data = {
  foo: 1,
  get bar () {
    return this.foo
  }
}
```

然后我们在 effect 副作用函数中通过代理对象 obj  访问 bar 属性：

```js
effect(() => console.log(obj.bar)) // 1
```

当我们尝试修改 `obj.foo` 的值时：

```js
obj.foo++
```

副作用函数并没有重新执行，问题出在哪呢？

实际上，问题就出在 bar 属性的访问器函数 getter 里，它里面的 this 指向的是谁？

我们在拦截器里面通过 ` target[key]` 来处理，相当于 `data.bar` 。因此，当我们使用 `obj.bar` 访问 bar 属性时，它的 getter 函数内的this 指向的其实是原始对象 data，这说明我们最终访问的其实是 data.foo。

很显然，在副作用函数内通过原始对象访问它的某个属性是不会建立响应联系的，这相当于：

```js
effecet(() => {
  // data 是原始数据，不是代理对象，这样的访问不能够建立响应联系
  data.foo
})
```

因为这样做不会建立响应联系，所以出现了无法触发响应的问题。那么如何解决这个问题呢？这时 `Reflect.get()` 函数就派对上用场了：

```js
const obj = new Proxy(data, {
  // 拦截读取操作，接收第三个参数 receiver
  get (target, key, receiver) {
    track(target, key)
    // 使用 Reflect.get() 返回读取到的属性值
    return Reflect.get(target, key, receiver)
  },
  // ...
})
```

`get()` 拦截器它的第三个参数 receiver 指的是谁在读取属性，例如：

```js
obj.foo
```

那么这个 receiver 就是 obj，你可以把它简单地理解为函数调用中的 this。接着关键的一步发生，我们使用 `Reflect.get(target, key, receiver)` 代替之前的 `taret[key]`，这里的关键点就是第三个参数 receiver。我们已经知道它就是代理对象 obj，所以访问器属性 bar 的 getter() 函数内的 this 就指向了代理对象 obj。

```js
const data = {
  foo: 1,
  get bar () {
    // 现在这里的 this 是代理对象 obj
    return this.foo
  }
}
```

可以看到，this 由原始对象 data 变成了代理对象 obj。很显然，这会在副作用函数与响应式数据之间建立响应联系，从而达到依赖收集的效果。如果此时再对 obj.foo 进行自增操作，会发现已经通解触发副作用函数重新执行了。

正是基于上述原因，后面的讲解将统一使用 Reflect.* 方法。

## JavaScript 对象及 Proxy 的工作原理

什么是对象？

根据 ECMAScript 规范，在 JavaScript 中有两种对象，其中一种对作**常规对象（ordinary object）**，另一种叫作**异质对象（exotic object）**。这两种对象包含了 JavaScript 世界中的所有对象。任何不属于常规对象的对象都是异质对象。

那么什么是常规对象、什么是异质对象呢？这需要我们先了解对象的内部方法和内部槽。

我们知道，在 JavaScript 中，函数其实也是对象。假设给出一个对象 obj，如何区分它是普通对象还是函数呢？

实际上，在 JavaScript 中，对象的实际语义是由对象的**内部方法（internal method）**指定的。所谓内部方法，指的是当我们对一个对象进行操作时，在引擎内部调用的方法，这些方法对于 JavaScript 使用者来说是不可见的。

举个例子，当我们访问对象的属性时：

```js
obj.foo
```

引擎内部会调用 `[[Get]]` 这个内部方法来读取属性值。这里补充说明一下，在 ECMAScript 规范中使用了 `[[xxx]]` 来代表内部方法或内部槽。当然，一个对象不仅部署了 `[[Get]]` 这个内部方法，下表列出了规范要求的所有必要的内部方法：

| 内部方法                | 签名                                               | 描述                                                         |
| ----------------------- | -------------------------------------------------- | ------------------------------------------------------------ |
| `[[GetPrototypeOf]]`    | `() -> Object | Null`                              | 查明为该对象提供继续属性的对象 null 代表没有继承属性         |
| `[[SetPrototypeOf]]`    | `(Object | Null) -> Boolean`                       | 将该对象与提供继续属性的另一个对象相关联。传递 null 表示没有继承属性，返回 true 表示操作成功完成，返回 false 表示操作失败 |
| `[[IsExtensible]]`      | `() -> Boolean`                                    | 查明是否允许向该对象添加其他属性                             |
| `[[PreventExtensions]]` | `() -> Boolean`                                    | 控制能否向该对象添加新属性。如果操作成功则返回 true，如果操作失败则返回 false |
| `[[GetOwnProperty]]`    | `(propertyKey) -> Undefined | Property Descriptor` | 返回该对象自身属性的描述符，其键为 propertyKey，如果不存在这样的属性，则返回 undefined |
| `[[DefineOwnProperty]]` | `(propertyKey, PropertyDescriptor) -> Boolean`     | 创建或更改自己的属性，其键为 propertyKey，以具有由 PropertyDescriptor 描述的状态。如果该属性已成功创建或更新，则返回 true；如果无法创建或更新该属性，则返回 false |
| `[[HasProperty]]`       | `(propertyKey) -> Boolean`                         | 返回一个布尔值，指示该对象是否已经拥有键为 propertyKey 的自己的或继承的属性 |
| `[[Get]]`               | `(propertyKey, Receiver) -> any`                   | 从该对象返回键为 propertyKey 的属性的值。如果必须运行 ECMAScript 代码来检索属性值，则在运行代码时使用 Receiver 作为 this 值 |
| `[[Set]]`               | `(propertyKey, value, Receiver) -> Boolean`        | 将键值为 propertyKey 的属性的值设置为 value。如果必须运行 ECMAScript 代码来设置属性值，则在运行代码时使用Receiver 作为 this 值。如果成功设置了属性值，则返回 true，如果无法设置，则返回 false |
| `[[Delete]]`            | `(propertyKey) -> Boolean`                         | 从对象中删除属于自身键为 propertyKey 的属性。如果该属性未被删除并且仍然存在，则返回 false；如果该属性已被删除或不存在，则返回 true |
| `[[OwnPropertyKeys]]`   | `() -> List of propertyKey`                        | 返回一个 List，其元素都是对象自身的属性键                    |

由上表（表1）可知，一个对象必须部署 11 个必要的内部方法。除了上表所列的内部方法之外，还有两个额外的必要内部方法：`[[Call]]` 和 `[[Construct]]`，如下表（表2）

| 内部方法        | 签名                                | 描述                                                         |
| --------------- | ----------------------------------- | ------------------------------------------------------------ |
| `[[Call]]`      | `(any, a List of any) -> any`       | 将运行代码与 this 对象关联。由函数调用触发。该内部方法的参数是一个 this 值和参数列表 |
| `[[Construct]]` | `(a List of any, Object) -> Object` | 创建一个对象。通过 new 运算符或 super 调用触发。该内部方法的第一个参数是一个 List，该  List 的元素是构造函数调用或 super 调用的参数，第二个参数是最初应用 new 运算符的对象。实现该内部方法的对象称为构造函数 |

如果一个对象需要作为函数调用，那么这个对象就必须部署内部方法`[[Call]]`。现在我们可以回答前面的问题了：如何区分一个对象是普通对象还是函数？一个对象在什么情况下作为函数调用呢？答案是，通过内部方法和内部槽来区分对象，例如函数对象会部署内部方法`[[Call]]`，而普通对象则不会。

内部方法具有金矿性，这是什么意思呢？这类似于面向对象里多态的概念。意思是说**不同类型的对象可能部署了相同的内部方法，却具有不同的逻辑**。例如普通对象和 Proxy 都部署了 `[[Get]]` 这个内部方法，但它们的逻辑是不同的，普通对象部署的 `[[Get]]` 内部方法是由 ECMA 规范的 10.1.8 节定义的，而 Proxy 对象部署的 `[[Get]]` 内部方法是由 ECMA 规范的 10.5.8 节来定义的。

了解了内部方法，就可以触发什么是常规对象，什么是异质对象了。

满足以下条件的对象就是**常规对象**：

+ 对于表1列出的内部方法，必须使用 ECMA 规范 10.1.x 节给出的定义实现；
+ 对于内部方法`[[Call]]`，必须使用 ECMA 规范 10.2.1 节给出的定义实现；
+ 对于内部方法`[[Construct]]`，必须使用 ECMA 规范 10.2.2 节给出的定义实现。

而所有不符合这三点要求的对象都是异质对象。例如 Proxy 对象的内部方法 `[[Get]]` 没有使用 ECMA 规范的 10.1.8 节给出的定义实现，所以 Proxy 是一个异质对象。

现在我们对 JavaScript 中的对象有了更加深入的理解。接下来，我们就具体看看 Proxy 对象。

```js
const p = new Proxy(obj, { /* ... */ })
p.foo
```

实际上，引擎会调用部署在对象 p 上的内部方法 `[[Get]]` 。到这一步，其实代理对象和普通对象没有太大的区别。它们的区别在于对于内部方法 `[[Get]]` 的实现，这里就体现了内部方法的多态性，即不同的对象部署相同的内部方法，但它们的行为可能不到。具体的不同体现在，如果创建代理对象时没有指定对应的拦截函数，例如没有指定 `get()` 拦截函数，那么当我们通过代理对象访问属性值时，代码对象的内部方法 `[[Get]]` 会调用原始对象的内部方法 `[[Get]]` 来获取属性值，这其实就是代理透明性质。

现在相信你已经明白了，创建代理对象时指定的拦截函数，实际上是用来自定义代理对象本身内部方法和行为的，而不是用来指定被代理对象方法和行为的。

表3列出了 Proxy 对象部署的内部方法以及用来自定义内部方法和行为的拦截函数名称：

| 内部方法                | 处理器函数               |
| ----------------------- | ------------------------ |
| `[[GetPropertyOf]]`     | getPropertyOf            |
| `[[SetPropertyOf]]`     | setPropertyOf            |
| `[[IsExtensible]]`      | isExtensible             |
| `[[PreventExtensions]]` | preventExtensions        |
| `[[GetOwnProperty]]`    | getOwnPropertyDescriptor |
| `[[DefineOwnProperty]]` | defineProperty           |
| `[[HasProperty]]`       | has                      |
| `[[Get]]`               | get                      |
| `[[Set]]`               | set                      |
| `[[Delete]]`            | deleteProperty           |
| `[[OwnPropertyKeys]]`   | ownKeys                  |
| `[[Call]]`              | apply                    |
| `[[Construct]]`         | construct                |

其中 `[[Call]]` 和 `[[Construct]]` 这两个内部方法只有当被代理的对象是函数和构造函数时才会部署。

由表3可知，当我们要拦截删除属性操作时，可以使用 `deleteProperty` 拦截函数：

```js
const obj = { foo: 1 }
const p = new Proxy(obj, {
  deleteProperty (target, key) {
    return Reflect.deleteProperty(target, key)
  }
})

console.log(p.foo) // 1
delete p.foo
console.log(p.foo) // undefined
```

## 如何代理 Object

前面我们使用 get 拦截函数去拦截对属性的读取操作。但在响应系统中，“读取”是一个很宽泛的概念，例如使用 in 操作符检查对象上是否存在给定的 key 也属于“读取”操作，如下代码所示：

```js
effect(() => {
  'foo' in obj
})
```

这本质上也是在进行“读取”操作。响应系统应该拦截一切读取操作，以便当数据变化时能够做出正确的响应。下面列出了对一个普通对象的所有可能读取操作：

+ 访问属性：`obj.foo`；
+ 判断对象或原型上是否存在给定的 key：`key in obj`；
+ 使用 `for...in` 循环遍历对象：`for (const key in obj)`。

接下来，我们逐步讨论如何拦截这些读取操作。首先是对于属性的读取，例如 `obj.foo`，我们知道这可以通过 `get()` 拦截函数实现：

```js
const obj = { foo: 1 }

const p = new Proxy(obj, {
  get (target, key, receiver) {
    track(traget, key)
    return Reflect.get(target, key, receiver)
  }
})
```

对于 in 操作符，应该如何拦截呢？我们可以先查看表3，尝试寻找与 in 操作符对应的拦截函数，但是表3中没有与   in 操作符相关的内容。怎么办呢？这时我们就需要查看关于 in 操作符的相关规范。在 ECMA-262 规范的 13.10.1 节中，明确定义了 in 操作符的运行时逻辑。它的第6步说明 in 操作符的 运行结果是通过调用一个叫作 HasProperty 的抽象方法得到的。关于 HasProperty 抽象方法，可以在 ECMA-262 规范的 7.3.11 节中找到，在第3步中，指出 HasProperty 抽象方法的返回值是通过调用对象的内部方法 `[[HasProperty]]` 得到的。而这个内部方法我们可以在表3中找到，它对应的拦截函数是 `has()`，因此我们可以通过 `has()` 拦截函数实现对 in 操作符的代理：

```js
const obj = { foo: 1 }
const p = new Proxy(obj, {
  get (target, key, receiver) {
    track(traget, key)
    return Reflect.has(target, key, receiver)
  }
})
```

再来看看如何拦截 `for...in` 循环，我们通过上述的查找方式，在 ECMA-262 规范的 14.7.5.6 节中找到 for...in 的头部执行规则，其第6点的第 c 子步骤表明它依赖一个 `EnumerateObjectProperties` 这个抽象方法。规范的 14.7.5.9 节中给出了满足该抽象方法的示例实现：

```js
function * EnumerateObjectProperties (obj) {
  const visited = new Set()

  for (const key of Reflect.ownKeys(obj)) {
    if (typeof key === 'symbol') {
      continue
    }
    
    const desc = Reflect.getOwnPropertyDescriptor(obj, key)
    
    if (desc) {
			visited.add(key)
      if (desc.enumerable) {
				yield key
      }
    }
	}
  
  const proto = Reflect.getPrototypeOf(obj)
  if (proto === null) {
    return
  }
  
  for (const protoKey of EnumerateObjectProperties(proto)) {
    if (!visited.has(protoKey)) {
			yield protoKey
    }
  }
}
```

可以看到关键点在于使用 Reflect.ownKeys(obj) 来获取只属于对象自身拥有的键。有了这个线索，如何拦截 `for...in` 循环的答案已经很明显了，我们可以使用 `ownKeys()` 拦截函数来拦截 Reflect.ownKeys 操作：

```js
const obj = { foo: 1 }
const ITERATE_KEY = Symbol()

cosnt p = new Proxy(obj, {
  ownKeys (target) {
		// 将副作用函数与 ITERATE_KEY 关联
    track(target, ITERATE_KEY)
    return Reflect.ownKeys(target)
  }
})
```

如上面的代码所示，拦截 ownKeys 操作即可间接拦截 for...in 循环。

我们在使用 `track()` 函数进行追踪的时候，将 ITERATE_KEY 作为追踪的 key，这是因为 `ownKeys()` 拦截函数与 `get()/set()` 拦截函数不同，我们无法拿到 key，只能拿到目标对象 target，所以我们需要构造一个唯一的 key 作为标识，即 ITERATE_KEY。

相应地，在触发响应时也应该触发它才行：

```js
trigger(target, ITERATE_KEY)
```

但是在什么情况下，对数据的操作需要触发与 ITERATE_KEY 相关联的副作用函数重新执行呢？我们用一段代码来说明：

```js
const obj = { foo: 1 }
const p = new Proxy(obj, { /* ... */ })

effect(() => {
  for (const key in p) {
    console.log(key)
  }
})
p.bar = 2
```

由于对象 p 原本只有 foo 属性，因此循环只会执行一些。当我们为它添加了新的属性 bar，循环就会由一次变成两次。也就是说，当为对象添加新属性时会对 `for...in` 循环产生影响，所以需要触发与 ITERATE_KEY 相关联的副作用函数重新执行。当然我们之前的实现还做不到这一点。

我们先看下 `set()` 拦截函数的实现：

```js
const p = new Proxy(obj, {
  set (target, key, newVal, receiver) {
    const res = Reflect.set(target, key, newVal, receiver)
    trigger(target, key)
    
    return res
  },
  // ...
})
```

当为对象 p 添加新的 bar 属性时，会触发 `set()` 拦截函数执行。此时接收到的 key 就是字符串 'bar'，因此 `trigger()` 函数也只会触发了与 'bar' 相关联的副作用函数重新执行。

但根据前文介绍，我们知道 for...in 循环是在副作用函数与 ITERATE_KEY 之间建立联系，这和 'bar' 无关，因此当我们尝试执行 p.bar = 2 操作时，并不能正确地触发响应。

弄清楚了问题在哪里，解决方案也就随之而来了。当添加属性时，我们将那些与 ITERATE_KEY 相关联的副作用函数也取出来执行就可以了：

```js
function trigger (target, key) {
  // 根据 target 从 bucket 中取出所有的 depsMap
  const depsMap = bucket.get(target)

  if (!depsMap) return true

  // 根据 key 从 depsMap 中取出所有的副作用函数
  const effects = depsMap.get(key)
  
  // 根据 ITERATE_KEY 从 depsMap 中取出所有的副作用函数
  const iterateEffects = depsMap.get(ITERATE_KEY)

  // effects && effects.forEach(fn => fn())

  // 用一个新的 Set 来完成 forEach 操作，防止添加时进入死循环
  const effectsToRun = new Set()

  effects && effects.forEach(effectFn => {
    // 如果 trigger 触发执行副作用函数与当前正在执行的副作用函数相同，则不触发
    if (effectFn !== activeEffect) {
      effectsToRun.add(effectFn)
    }
  })
  
  iterateEffects && iterateEffects.forEach(effectFn => {
    // 如果 trigger 触发执行副作用函数与当前正在执行的副作用函数相同，则不触发
    if (effectFn !== activeEffect) {
      effectsToRun.add(effectFn)
    }
  })
  
  effectsToRun.forEach(effectFn => {
    // 如果该副作用函数存在调度器，则调用该调度器，并将副作用函数作为参数传递
    if (effectFn.options.scheduler) {
      effectFn.options.scheduler(effectFn)
    } else {
      // 否则直接执行副作用函数
      effectFn()
    }
  })
}
```

如上代码所示，当 `trigger()` 函数执行时，除了把那些直接与具体操作的 key 相关联的副作用函数取出来执行之外，还要把那么与 ITERATE_KEY 相关联的副作用函数取出来执行。

对于添加新的属性来说，这样做没什么问题，但是修改已有的属性，那么问题就来了：

```js
const obj = { foo: 1 }
const p = new Proxy(obj, { /* ... */ })

effect(() => {
  for (const key in p) {
    console.log(key)
  }
})
p.foo = 2
```

与添加新属性不同，修改属性 对于 for...in 循环来说都只会循环一次。所以在这种情况下，我们不需要触发副作用函数重新执行，否则会造成不必要的性能开销。然而无论是添加新属性，还是修改已有的属性，我们都是通过其基本语义 `[[Set]]` ，也就是通过 `set()` 拦截函数来实现拦截的。

所以我们需要在 `set()` 拦截函数内部判断到底是新增还是修改属性：

```js
const p = new Proxy(obj, {
  set (target, key, newValue, receiver) {
		// 如果属性不存在，则说明是在新增属性，否则是修改属性
    const type = Object.prototyp.hasOwnProperty.call(target, key)
    	? 'SET'
    	: 'ADD'
    
    const res = Reflect.set(target, key, newValue, receiver)
    
    // 将 type 作为第三个参数传递给 trigger() 函数
    trigger(target, key, type)
    
    return res
  },
  // ...
})
```

那么我们就可以在 `trigger()` 函数内通过 type 来区分当前的操作类型，并且只有当 type 为 'ADD' 时，才触发与 ITERATE_KEY 相关联的副作用函数重新执行，这样就避免了不必要的性能开销：

```js
function trigger (target, key, type) {
  // 根据 target 从 bucket 中取出所有的 depsMap
  const depsMap = bucket.get(target)

  if (!depsMap) return true

  // 根据 key 从 depsMap 中取出所有的副作用函数
  const effects = depsMap.get(key)
  
  // 根据 ITERATE_KEY 从 depsMap 中取出所有的副作用函数
  const iterateEffects = depsMap.get(ITERATE_KEY)

  // effects && effects.forEach(fn => fn())

  // 用一个新的 Set 来完成 forEach 操作，防止添加时进入死循环
  const effectsToRun = new Set()

  effects && effects.forEach(effectFn => {
    // 如果 trigger 触发执行副作用函数与当前正在执行的副作用函数相同，则不触发
    if (effectFn !== activeEffect) {
      effectsToRun.add(effectFn)
    }
  })
  
  // 只有当操作类型为 'ADD' 时，才触发与 ITERATE_KEY 相关联的副作用函数重新执行
  if (type === 'ADD') {
    iterateEffects && iterateEffects.forEach(effectFn => {
      // 如果 trigger 触发执行副作用函数与当前正在执行的副作用函数相同，则不触发
      if (effectFn !== activeEffect) {
        effectsToRun.add(effectFn)
      }
    })
  }
  
  effectsToRun.forEach(effectFn => {
    // 如果该副作用函数存在调度器，则调用该调度器，并将副作用函数作为参数传递
    if (effectFn.options.scheduler) {
      effectFn.options.scheduler(effectFn)
    } else {
      // 否则直接执行副作用函数
      effectFn()
    }
  })
}
```

通常我们会将操作类型封装为一个枚举值，这样无论是对后期代码的维护，还是对代码的清晰度，都是非常有帮助的：

```js
const TriggerType = {
  ADD: 'ADD',
  SET: 'SET'
}
```

关于对象的代理，还剩下最后一项工作需要做，即删除属性操作的代理：

```js
delete p.foo
```

在 ECMA-262 规范中的 13.5.1.2 节的第5步中的 d 子步骤中指出 delete 操作符依赖 `[[Delete]]` 内部方法。查看表3可知，该内部方法可以使用 deleteProperty 拦截：

```js
const p = new Proxy(obj, {
  deleteProperty (target, key) {
    // 检查被操作的属性是否是对象自己的属性
    const hadKey = Object.prototype.hasOwnProperty.call(target, key)
    
    const res = Reflect.deleteProperty(target, key)
    
    if (res && hadKey) {
      // 只有当被删除的属性是对象自己的属性并且成功删除时，才触发更新
      trigger(target, key, 'DELETE')
    }
    
    return res
  }
})
```

需要注意的时，在调用 `trigger()` 函数时，我们传递了新的操作类型 'DELETE'。由于删除操作会影响 for...in 循环的次数，因此操作类型为 'DELETE' 时，我们也应该触发那些与 ITERATE_KEY 相关联的副作用函数重新执行：

```js
function trigger (target, key, type) {
  // 根据 target 从 bucket 中取出所有的 depsMap
  const depsMap = bucket.get(target)

  if (!depsMap) return true

  // 根据 key 从 depsMap 中取出所有的副作用函数
  const effects = depsMap.get(key)
  
  // 根据 ITERATE_KEY 从 depsMap 中取出所有的副作用函数
  const iterateEffects = depsMap.get(ITERATE_KEY)

  // effects && effects.forEach(fn => fn())

  // 用一个新的 Set 来完成 forEach 操作，防止添加时进入死循环
  const effectsToRun = new Set()

  effects && effects.forEach(effectFn => {
    // 如果 trigger 触发执行副作用函数与当前正在执行的副作用函数相同，则不触发
    if (effectFn !== activeEffect) {
      effectsToRun.add(effectFn)
    }
  })
  
  // 只有当操作类型为 'ADD' 或 'DELETE' 时，才触发与 ITERATE_KEY 相关联的副作用函数重新执行
  if (
    type === 'ADD' ||
    type === 'DELETE'
  ) {
    iterateEffects && iterateEffects.forEach(effectFn => {
      // 如果 trigger 触发执行副作用函数与当前正在执行的副作用函数相同，则不触发
      if (effectFn !== activeEffect) {
        effectsToRun.add(effectFn)
      }
    })
  }
  
  effectsToRun.forEach(effectFn => {
    // 如果该副作用函数存在调度器，则调用该调度器，并将副作用函数作为参数传递
    if (effectFn.options.scheduler) {
      effectFn.options.scheduler(effectFn)
    } else {
      // 否则直接执行副作用函数
      effectFn()
    }
  })
}
```

## 合理地触发响应

当值没有发生变化时，应该不需要触发响应：

```js
const obj = { foo: 1 }
const p = new Proxy(obj, { /* ... */ })

effect(() => {
  console.log(p.foo)
})

p.foo = 1 // 设置了值，但没有变化
```

所以我们需要修改 `set()` 拦截函数的代码，在调用 `trigger()` 函数触发响应之前，需要检查值是否真的发生了变化：

```js
const p = new Proxy(obj, {
  set (target, key, newValue, receiver) {
		// 先获取旧值
    const oldValue = target[key]
    
    const type = Object.prototyp.hasOwnProperty.call(target, key)
    	? 'SET'
    	: 'ADD'
    
    const res = Reflect.set(target, key, newValue, receiver)
    
    // 比较新值与旧值，只有当不全等的时候才触发响应
    if (oldValue !== newValue) {
      // 将 type 作为第三个参数传递给 trigger() 函数
      trigger(target, key, type)
    }
    
    return res
  }
})
```

然后，仅仅是进行全等比较是有缺陷的，这体现在对 NaN 的处理上。我们知道 NaN 与 NaN 的全等比较总会得到 false。

为了解决这个问题，我们需要加一个条件，需要确保它们不是 NaN：

```js
const p = new Proxy(obj, {
  set (target, key, newVal, receiver) {
		// 先获取旧值
    const oldVal = target[key]
    
    const type = Object.prototyp.hasOwnProperty.call(target, key)
    	? 'SET'
    	: 'ADD'
    
    const res = Reflect.set(target, key, newVal, receiver)
    
    // 比较新值与旧值，只有当不全等的时候
    // 并且它们都不是 NaN 时才触发响应
    if (
      oldVal !== newVal &&
      (
      	oldVal === oldVal ||
        newVal === newVal
      )
    ) {
      // 将 type 作为第三个参数传递给 trigger() 函数
      trigger(target, key, type)
    }
    
    return res
  }
})
```

这样我们就解决了 NaN 的问题。

但想要合理地触发响应，仅仅处理关于 NaN 问题还不够。接下来，我们讨论一种从原型上继承属性的情况。为了后续讲解方便，我们需要封装一个 `reactive()` 函数，该函数接收一个对象作为参数，并返回为其创建的响应式数据：

```js
function reactive (obj) {
  return new Proxy(obj, {
    // 拦截读取操作
    get (target, key, receiver) {
      track(target, key)
  
      // 返回属性值
      return Reflect.get(target, key, receiver)
    },
  
    // 拦截设置操作
    set (target, key, newVal, receiver) {
      // 先获取旧值
      const oldVal = target[key]

      // 如果属性不存在，则说明是在新增属性
      // 否则是修改属性
      const type = Object.prototype.hasOwnProperty.call(target, key)
        ? TriggerType.SET
        : TriggerType.ADD

      // 设置属性值
      const res = Reflect.set(target, key, newVal, receiver)
      
      // 比较新值与旧值，只有当不全等的时候
      // 并且它们都不是 NaN 时才触发响应
      if (
        oldVal !== newVal &&
        (
          oldVal === oldVal ||
          newVal === newVal
        )
      ) {
        // 将 type 作为第三个参数传递给 trigger() 函数
        trigger(target, key, type)
      }
  
      return res
    },

    ownKeys (target) {
      // 将副作用函数与 ITERATE_KEY 关联
      track(target, ITERATE_KEY)
      return Reflect.ownKeys(target)
    },

    deleteProperty (target, key) {
      // 检查被操作的属性是否是对象自己的属性
      const hadKey = Object.prototype.hasOwnProperty.call(target, key)
      
      const res = Reflect.deleteProperty(target, key)
      
      if (res && hadKey) {
        // 只有当被删除的属性是对象自己的属性并且成功删除时，才触发更新
        trigger(target, key, 'DELETE')
      }
      
      return res
    },

    // 拦截函数调用
    apply (target, thisArg, argsList) {
      Reflect.apply(target, thisArg, argsList)
    }
  })
}
```

封装好之后，我们看一下下面的例子：

```js
const obj = {}
const proto = { bar: 1 }
const child = reactive(obj)
const parent = reactive(proto)
// 使用 parent 作为 child 的原型
Object.setPrototypeOf(child, parent)

effect(() => {
  console.log(child.bar)
})

child.bar = 2
```

当我们运行时，会发现副作用函数执行了两次，这是为什么呢？

我们来分析一下，当在副作用函数中读取 child.bar 的值时，会触发 child 代理对象的 `get()` 拦截函数。我们知道，拦截函数内部是使用了 `Reflect.get(target, key, receiver)` 来得到最终结果的。

这其实是实现 了通过 obj.bar 来访问属性值的默认行为。也就是说，引擎内部是通过调用 obj 对象所部署的 `[[Get]]` 内部方法来得到最终结果的。在 ECMA-262 规范的 10.1.8.1 中的第3步，我们可以了解到：如果对象自身不存在该属性，会获取对象的原型，并调用原型的 `[[Get]]` 方法得到最终结果。

对应到上面的例子中，当读取 child.bar 属性值时，由于 child 代理的对象 obj 上没有 bar 这个属性，因此会获取它的原型，也就是 parent 对象，所以最终得到的实际上是 parent.bar 值。

然而 parent 也是一个响应值，它读取属性时也会被副作用函数收集，从而建立响应联系。

所以我们可以得出个结论，即 child.bar 和 parent.bar 都与副作用函数建立了响应联系。

但这仍然无法解释为什么当设置 child.bar 的值时，会连续触发两次副作用函数执行，所以我们需要继续分析一下设置操作的执行流程。我们知道，在 `set()` 拦截函数内，我们使用了 `Reflect.set(target, key, newVal, receiver)` 来完成默认的行为，即引擎会调用 obj 对象部署的 `[[Set]]` 内部方法，在 ECMA-262 规范的 10.1.9.2 节的第2步指出，如果设置的值不存在于该对象上，那么会取其原型，并调用原型的 `[[Set]]` 方法，这就和 `[[Get]]` 的流程一样了。

所以我们在设置 child.bar 的值时，会导致副作用函数执行两次。

接下来我们思考一下解决方案。思路很简单，既然执行两次，那么我们屏蔽其中一次就可以了。

```js
// 拦截设置操作
set (target, key, newVal, receiver) {
  console.log(target, receiver)
  // ...
}
```

如上代码所示，我们在 `set()` 拦截函数中看看两次的拦截会有什么异同点。我们给上面的例子加点方便辨别的代码，然后再运行一下：

```js
const obj = { name: 'obj' }
const proto = { name: 'proto', bar: 1 }
const child = reactive(obj)
child.name = 'child'
const parent = reactive(proto)
parent.name = 'parent'
// 使用 parent 作为 child 的原型
Object.setPrototypeOf(child, parent)

effect(() => {
  console.log(child.bar)
})

child.bar = 2
```

控制台输出如下：

```
{name: 'obj'} Proxy {name: 'obj'}
{name: 'proto', bar: 1} Proxy {name: 'proto', bar: 1}
1

{name: 'child'} Proxy {name: 'child'}
{name: 'parent', bar: 1} Proxy {name: 'child'}
2
2
```

我们可以发现，第一次 `set()` 函数执行时，target 是原始对象 obj，receiver 是代理对象 child，我们发现**receiver 是 target 的代理对象**；而第二次 `set()` 函数执行时，target 是原始对象 proto，receiver 是仍然代理对象 child，而**不再是 target 的代理对象。**通过这个特点，我们可以看到 target 和 receiver 的区别。由于我们最初设置的 child.bar 的值，所以无论在什么情况下 receiver 都是 child，而 target 是变化的。有了这个区别，那么我们只需要判断 receiver 是否为 target 的代理对象即可。只有当 receiver 是 target 的代理对象时才触发更新，这样就能够屏蔽由原型引起的更新了。

所以接下来的问题就变成了如何确定 receiver 是 target 的代理对象即可，这需要我们为 `get()` 拦截函数增加一个能力，如下代码所示：

```js
const RAW = 'RAW'

function reactive (obj) {
  return new Proxy(obj, {
    // 拦截读取操作
    get (target, key, receiver) {
      // 代理对象可以通过 Symbol.for(RAW) 属性访问原始数据
      if (key === Symbol.for(RAW)) {
        return target
      }

      track(target, key)
  
      // 返回属性值
      return Reflect.get(target, key, receiver)
    },
    // ...
  })
}
```

我们增加了一段代码，它实现的功能是，代理对象可以通过 `Symbol.for(RAW)` 属性来读取原始数据，例如：

```js
console.log(child[Symbol.for(RAW)] === obj) // true
console.log(parent[Symbol.for(RAW)] === proto) // true
```

有了它，我们就能够在 set 拦截函数中判断 receiver 是不是 target 的代理对象了：

```js
function reactive (obj) {
  return new Proxy(obj, {
    // 拦截设置操作
    set (target, key, newVal, receiver) {
      // 先获取旧值
      const oldVal = target[key]

      // 如果属性不存在，则说明是在新增属性
      // 否则是修改属性
      const type = Object.prototype.hasOwnProperty.call(target, key)
        ? TriggerType.SET
        : TriggerType.ADD

      // 设置属性值
      const res = Reflect.set(target, key, newVal, receiver)

      // target === receiver[Symbol.for(RAW)] 说明 receiver 就是 target 的代理对象
      if (target === receiver[Symbol.for(RAW)]) {
        // 比较新值与旧值，只有当不全等的时候
        // 并且它们都不是 NaN 时才触发响应
        if (
          oldVal !== newVal &&
          (
            oldVal === oldVal ||
            newVal === newVal
          )
        ) {
          // 将 type 作为第三个参数传递给 trigger() 函数
          trigger(target, key, type)
        }
      }
  
      return res
    },
    // ...
  })
}
```

如上代码所示，我们增加了一个判断条件，只有当 receiver 是 target 的代理对象时才触发更新，这样就能屏蔽由原型所引起的不必要更新。

## 浅响应和深响应

目前为止，我们实现的都是浅响应。

实现深响应式的方式也很简单：当我们读取的属性值是一个普通对象时，我们再递归使用 `reactive()` 包装一层即可：

```js
function reactive (obj) {
  return new Proxy(obj, {
    // 拦截读取操作
    get (target, key, receiver) {
      // 代理对象可以通过 Symbol.for(RAW) 属性访问原始数据
      if (key === Symbol.for(RAW)) {
        return target
      }

      track(target, key)
  
      // 得到原始值结果
      const res = Reflect.get(target, key, receiver)
      if (typeof res === 'object' && res !== null) {
        return reactive(res)
      }

      return res
    },
    // ...
  })
}
```

然而，并非所有情况我们都需要深响应的，这就催生了  `shalloReactive`，即浅响应。所谓浅响应，指的是只有对象的第一层属性是响应的，所以我们需要对代码进行一下改动，把 `reactive()` 函数重命名为 `createReactive()` 函数，并增加参数：

```js
// 封装 createReactive() 函数，多接收一个参数 isShallow，代表是否为浅响应，默认为 false
function createReactive (obj, isShallow = false) {
  return new Proxy(obj, {
    // 拦截读取操作
    get (target, key, receiver) {
      // 代理对象可以通过 Symbol.for(RAW) 属性访问原始数据
      if (key === Symbol.for(RAW)) {
        return target
      }

      track(target, key)
  
      // 得到原始值结果
      const res = Reflect.get(target, key, receiver)

      // 如果是浅响应，直接返回原始值
      if (isShallow) {
        return res
      }

      if (typeof res === 'object' && res !== null) {
        return reactive(res)
      }

      return res
    },
    // ...
  })
}
```

然后增加两个函数 `reactive()` 和 `shallowReactive()` ：

```js
function reactive (obj) {
  return createReactive(obj)
}

function shallowReactive (obj) {
  return createReactive(obj, true)
}
```

## 只读和浅只读

某些时候，我们需要数据是只读的，当用户尝试修改只读数据时，会收到一条警告信息。这样就实现了对数据的保护。

只读本质上也是对数据对象的代理，我们同样可以使用 `createReactive()` 函数来实现，如下代码所示，我们为 `createReactive()` 函数增加第三个参数：

```js
// 增加第三个参数，isReadonly 代表是否为只读，默认为 false
function createReactive (obj, isShallow = false, isReadonly = false) {
  return new Proxy(obj, {
    // 拦截读取操作
    get (target, key, receiver) {
      // 代理对象可以通过 Symbol.for(RAW) 属性访问原始数据
      if (key === Symbol.for(RAW)) {
        return target
      }

      track(target, key)
  
      // 得到原始值结果
      const res = Reflect.get(target, key, receiver)

      // 如果是浅响应，直接返回原始值
      if (isShallow) {
        return res
      }

      if (typeof res === 'object' && res !== null) {
        return reactive(res)
      }

      return res
    },
  
    // 拦截设置操作
    set (target, key, newVal, receiver) {
      // 如果是只读的，则打印警告信息
      if (isReadonly) {
        console.warn(`属性 ${key} 是只读的`)
        return true
      }

      // 先获取旧值
      const oldVal = target[key]

      // 如果属性不存在，则说明是在新增属性
      // 否则是修改属性
      const type = Object.prototype.hasOwnProperty.call(target, key)
        ? TriggerType.SET
        : TriggerType.ADD

      // 设置属性值
      const res = Reflect.set(target, key, newVal, receiver)

      // target === receiver[Symbol.for(RAW)] 说明 receiver 就是 target 的代理对象
      if (target === receiver[Symbol.for(RAW)]) {
        // 比较新值与旧值，只有当不全等的时候
        // 并且它们都不是 NaN 时才触发响应
        if (
          oldVal !== newVal &&
          (
            oldVal === oldVal ||
            newVal === newVal
          )
        ) {
          // 将 type 作为第三个参数传递给 trigger() 函数
          trigger(target, key, type)
        }
      }
  
      return res
    },

    deleteProperty (target, key) {
      // 如果是只读的，则打印警告信息
      if (isReadonly) {
        console.warn(`属性 ${key} 是只读的`)
        return true
      }

      // 检查被操作的属性是否是对象自己的属性
      const hadKey = Object.prototype.hasOwnProperty.call(target, key)
      
      const res = Reflect.deleteProperty(target, key)
      
      if (res && hadKey) {
        // 只有当被删除的属性是对象自己的属性并且成功删除时，才触发更新
        trigger(target, key, 'DELETE')
      }
      
      return res
    },
    // ...
  })
}
```

当然如果一个数据是只读的，那么就没有必要再为它建立响应联系，出于这个原因，不需要调用 `track()` 函数来追踪响应：

```js
function createReactive (obj, isShallow = false, isReadonly = false) {
  return new Proxy(obj, {
    // 拦截读取操作
    get (target, key, receiver) {
      // 代理对象可以通过 Symbol.for(RAW) 属性访问原始数据
      if (key === Symbol.for(RAW)) {
        return target
      }
      // 非只读的时候才需要建立响应联系
      if (!isReadonly) {
        track(target, key)
      }
  
      // 得到原始值结果
      const res = Reflect.get(target, key, receiver)

      // 如果是浅响应，直接返回原始值
      if (isShallow) {
        return res
      }

      if (typeof res === 'object' && res !== null) {
        return reactive(res)
      }

      return res
    },
    // ...
  })
}
```

基于此，我们就可以实现 `readonly()` 函数了：

```js
function readonly (obj) {
  return createReactive(obj, false, true /* 只读 */)
}
```

然而上面的函数更应该叫做 `shallowReadonly()` ，因为它还没做到深只读。为了实现深只读，我们还应该在 `get()` 拦截函数中递归调用 `readonly()` 将数据包装成只读的代理对象，并将其作为返回值返回：

```js
function createReactive (obj, isShallow = false, isReadonly = false) {
  return new Proxy(obj, {
    // 拦截读取操作
    get (target, key, receiver) {
      if (key === Symbol.for(RAW)) {
        return target
      }

      if (!isReadonly) {
        track(target, key)
      }
  
      const res = Reflect.get(target, key, receiver)

      if (isShallow) {
        return res
      }

      if (typeof res === 'object' && res !== null) {
        // 如果数据是只读，则调用 readonly 对值进行包装
        return isReadonly
          ? readonly(res)
          : reactive(res)
      }

      return res
    },
    // ...
  })
}
```

如上面的代码所示，我们在返回属性值之前，判断它是否是只读的，如果是只读的，则调用 `readonly()` 函数进行包装并返回包装后的只读对象。

对于 `shallowReadonly()` ，我们只需要修改 `createReactive()` 的第二个参数即可：

```js
function readonly (obj) {
  return createReactive(obj, false, true /* 只读 */)
}

function shallowReadonly (obj) {
  return createReactive(obj, true /* shallow */, true /* 只读 */)
}
```

## 代理数组

数组是一个异质对象，除了 `[[DefineOwnProperty]]` 这个内部方法与常规对象不同之外，其实的内部方法的逻辑都与常规对象相同。因此，在对数组代理时，用于代理普通对象的大部分代码都可以继续使用。

但对数组的操作与普通对象的操作仍然存在不同，下面总结了所有对数组元素或属性的**读取操作**：

+ 通过索引访问数组元素值：arr[0]；
+ 访问数组的长度：arr.length；
+ 把数组作为对象，使用 for...in 循环遍历；
+ 使用 for...of 迭代遍历数组；
+ 数组的原型方法，如 concat/join/every/som/find/findIndx/includes 等，以及其他所有不改变原数组的原型方法。

**设置操作**：

+ 通过索引修改数组元素的值：arr[0] = 1；
+ 修改数组的长度：arr.length = 0；
+ 数组的栈方法：push/pop/unshift/shift；
+ 修改原数组的原型方法：splice/fill/sort 等。

除了通过数组索引修改数组元素值这种基本操作之外，数组本身还有很多会修改原数组的原型方法。调用这些方法也属于对数组的操作，有些方法的操作语义是“读取”，而有些方法的操作语义是“设置”。因此，当这些操作发生时，也应该正确地建立响应联系或触发响应。

## 数据的索引与 length

通过数组的索引访问元素的值时，已经能够建立响应联系：

```js
const arr = reactive(['foo'])

effect(() => {
  console.log(arr[0]) // 'foo'
})

arr[0] = 'bar' // 能够触发响应
```

但通过索引设置数组的元素值与设置对象的属性值存在根本上的不同，这是因为数组对象的内部方法 `[[DefineOwnProperty]]` 不同于常规对象。

实际上，当我们通过索引设置数组元素的值时，会执行数组对象的内部方法 `[[Set]]`，这一步与常规对象的设置属性值是一样的。根据规范可知，内部方法 `[[Set]]` 其实依赖了 `[[DefineOwnProperty]]`，到这里就体现出了差异。

数组对象所部署的内部方法 `[[DefineOwnProperty]]` 的逻辑定义在规范的 10.4.2.1 节的第 3步的 j 子步骤中指出：如果设置的索引值大于数组当前的长度，那么要更新 length 属性。所以当通过索引设置元素值时，可能会隐式地修改 length 的属性值。因此在触发响应时，也应该触发与 length 属性相关联的副作用函数重新执行：

```js
const arr = reactive(['foo'])

effect(() => {
  console.log(arr.length) // 1
})

arr[1] = 'bar' // 设置索引 1 的值，会导致数组的长度变为 2
```

所以我们需要修改 `set()` 拦截函数：

```js
function createReactive (obj, isShallow = false, isReadonly = false) {
  return new Proxy(obj, {
    // 拦截设置操作
    set (target, key, newVal, receiver) {
      // 如果是只读的，则打印警告信息
      if (isReadonly) {
        console.warn(`属性 ${key} 是只读的`)
        return true
      }

      // 先获取旧值
      const oldVal = target[key]

      // 如果属性不存在，则说明是在新增属性
      // 否则是修改属性
      const type = Array.isArray(target)
        // + 如果代理目标是数组，则检测被设置的索引值是否小于数组长度，
        // + 如果是，则视作 SET 操作，否则是 ADD 操作
        ? Number(key) < target.length ? TriggerType.SET : TriggerType.ADD
        : Object.prototype.hasOwnProperty.call(target, key) ? TriggerType.SET : TriggerType.ADD

      // 设置属性值
      const res = Reflect.set(target, key, newVal, receiver)

      // target === receiver[Symbol.for(RAW)] 说明 receiver 就是 target 的代理对象
      if (target === receiver[Symbol.for(RAW)]) {
        // 比较新值与旧值，只有当不全等的时候
        // 并且它们都不是 NaN 时才触发响应
        if (
          oldVal !== newVal &&
          (
            oldVal === oldVal ||
            newVal === newVal
          )
        ) {
          // 将 type 作为第三个参数传递给 trigger() 函数
          trigger(target, key, type)
        }
      }
  
      return res
    },
    // ...
  })
}
```

这样，我们就可以在 `trigger()` 函数中正确地触发与数组的 length 属性相关联的副作用函数重新执行了：

```js
function trigger (target, key, type) {
  // 根据 target 从 bucket 中取出所有的 depsMap
  const depsMap = bucket.get(target)

  if (!depsMap) return true

  // ... 省略部分代码

  // 当操作类型为 ADD 且目标对象是数组时，
  // 应取出并执行与 length 相关联的副作用函数
  if (type === TriggerType.ADD && Array.isArray(target)) {
    const lengthEffects = depsMap.get('length')
    lengthEffects && lengthEffects.forEach(effectFn => {
      if (effectFn !== activeEffect) {
        effectsToRun.add(effectFn)
      }
    })
  }

  effectsToRun.forEach(effectFn => {
    // 如果该副作用函数存在调度器，则调用该调度器，并将副作用函数作为参数传递
    if (effectFn.options.scheduler) {
      effectFn.options.scheduler(effectFn)
    } else {
      // 否则直接执行副作用函数
      effectFn()
    }
  })
}
```

反过来思考，其实修改数组的 length 属性也会隐式地影响数组元素。当修改 length 属性时，只有那些索引值大于或等于新的 length 属性值的元素才需要触发响应。所以我们需要继续修改 `set()` 拦截函数：

```js
function createReactive (obj, isShallow = false, isReadonly = false) {
  return new Proxy(obj, {
    // 拦截设置操作
    set (target, key, newVal, receiver) {
      // 如果是只读的，则打印警告信息
      if (isReadonly) {
        console.warn(`属性 ${key} 是只读的`)
        return true
      }

      // 先获取旧值
      const oldVal = target[key]

      // 如果属性不存在，则说明是在新增属性
      // 否则是修改属性
      const type = Array.isArray(target)
        // + 如果代理目标是数组，则检测被设置的索引值是否小于数组长度，
        // + 如果是，则视作 SET 操作，否则是 ADD 操作
        ? Number(key) < target.length ? TriggerType.SET : TriggerType.ADD
        : Object.prototype.hasOwnProperty.call(target, key) ? TriggerType.SET : TriggerType.ADD

      // 设置属性值
      const res = Reflect.set(target, key, newVal, receiver)

      // target === receiver[Symbol.for(RAW)] 说明 receiver 就是 target 的代理对象
      if (target === receiver[Symbol.for(RAW)]) {
        // 比较新值与旧值，只有当不全等的时候
        // 并且它们都不是 NaN 时才触发响应
        if (
          oldVal !== newVal &&
          (
            oldVal === oldVal ||
            newVal === newVal
          )
        ) {
          // 增加第四个参数，即触发响应的新值
          trigger(target, key, type, newVal)
        }
      }
  
      return res
    },
    // ...
  })
}
```

同样我们需要修改 `trigger()` 函数：

```js
function trigger (target, key, type, newVal) {
  // 根据 target 从 bucket 中取出所有的 depsMap
  const depsMap = bucket.get(target)

  if (!depsMap) return true

  // ... 省略部分代码

  // 如果操作目标是数组，并且修改了 length 属性
  if (Array.isArray(target) && key === 'length') {
    // 对于索引大于或等于新的 length 值的元素，
    // 需要把所有相关联的副作用函数取出并添加到 effectsToRun 中待执行
    depsMap.forEach((effects, key) => {
      if (key >= newVal) {
        effects.forEach(effectFn => {
          if (effectFn !== activeEffect) {
            effectsToRun.add(effectFn)
          }
        })
      }
    })
  }

  effectsToRun.forEach(effectFn => {
    // 如果该副作用函数存在调度器，则调用该调度器，并将副作用函数作为参数传递
    if (effectFn.options.scheduler) {
      effectFn.options.scheduler(effectFn)
    } else {
      // 否则直接执行副作用函数
      effectFn()
    }
  })
}
```

## 遍历数组

既然数组也是对象， 就意味着同样可以使用 `for...in` 循环遍历，并且与常规对象无差异，同样使用 `ownKeys()` 拦截函数进行拦截。

不过，对于数组来说情况有所不同，下面列出哪些操作会影响 for...in 循环对数组的遍历：

+ 添加新元素：arr[100] = bar；
+ 修改数组长度：arr.length = 0。

其实，无论是为数组添加新元素，还是直接修改数组的长度，本质上都是因为修改了数组的 length 属性。所以我们只需要在 `ownKeys()` 拦截函数内，判断当前操作目标 target 是否是数组，如果是，则使用 length 作为 key 去建立响应联系：

```js
function createReactive (obj, isShallow = false, isReadonly = false) {
  return new Proxy(obj, {
    ownKeys (target) {
      // 如果操作目标 target 是数组，则使用 length 属性作为 key 并建立响应联系
      track(target, Array.isArray(target) ? 'length' : ITERATE_KEY)
      return Reflect.ownKeys(target)
    },
    // ...
  })
}
```

这样就能够正确地触发响应了。

接下来我们看看使用 for...of 遍历数组的情况。与 for...in 不同，for...of 是用来遍历**可迭代对象（iterable object）**的，因此我们需要先搞清楚什么是可迭代对象。ES2015 为 JavaScript 定义了**迭代协议（iteration protocol）。**具体来说，一个对象能否被迭代，取决于该对象或者该对象的原型是否实现了 @@iterator 方法。

这里的 @@[name] 标志在 ECMAScript 规范里用来代指 JavaScript 内建的 symbols 值，例如 @@iterator 指的就是 Symbol.iterator 这个值。如果一个对象实现了 Symbol.iterator 方法，那么这个对象就是可迭代的：

```js
const  obj = {
  val: 0,
  [Symbol.iterator] () {
    return {
      next () {
        value: obj.val++,
          done: obj.val > 10 ? true : false
      }
    }
  }
}
```

该对象实现了 Symbol.iterator 方法，因此可以使用 for...of 循环遍历它：

```js
for (const value of obj) {
  console.log(value) // 0 1 2 3 4 5 6 7 8 9
}
```

数组内建了 Symbol.iterator 方法的实现，我们可以做一个实验：

```js
const arr = [1, 2, 3, 4, 5]
const it = arr[Symbol.iterator]()

console.log(it.next()) // { value: 1, done: false }
console.log(it.next()) // { value: 2, done: false }
console.log(it.next()) // { value: 3, done: false }
console.log(it.next()) // { value: 4, done: false }
console.log(it.next()) // { value: 5, done: false }
console.log(it.next()) // { value: undefined, done: true }
```

可以看到，我们能够通过将 Symbol.iterator 作为键，获取数组内建的迭代器方法。然后手动执行迭代器的 next 函数，这样也可以得到期望的结果。这也是默认情况下数组可以使用 for...of 遍历的原因。

实际上，想要实现对数组进行 for...of 遍历操作的拦截，关键点在于找到 for...of 操作依赖的基本语义。在 ECMA-262 规范的 23.1.5.1 节中的第 3 步的 b 子步骤指出：数组的迭代器的执行会读取数组的 length 属性。如果迭代的是数组元素值，还会读取数组的索引。

我们来模拟一下数组迭代器的实现：

```js
const arr = [1, 2, 3, 4, 5]

arr[Symbol.iterator] = function () {
  const target = this
  const len = target.length
  let index = 0
  
  return {
    next () {
      return {
        value: index < len ? target[index] : undefined,
        done: index++ >= len
      }
    }
  }
}
```

这个例子表明，迭代数组时，只需要在副作用函数与数组的长度和索引之间建立响应联系，就能够实现响应式的 for...of 迭代。

```js
const arr = reactive([1, 2, 3, 4, 5])

effect(() => {
  for (const val of arr) {
    console.log(val)
  }
})

arr[1] = 'bar' // 能够触发响应
arr.length = 0 // 能够触发响应
```

这里不得不提一点的是，数组的 values 方法的返回值实际上就是数组内建的迭代器：

```js
console.log(Array.prototype.values === Array.prototype[Symbol.iterator]) // true
```

换句话说，在不增加任何代码的情况下，我们也能够让数组的迭代器方法正确地工作。

最后需要指出的是，无论是使用 for...of 循环，还是调用 values 等方法，它们都会读取数组的 Symbol.iterator 属性。该属性是一个 Symbol 值，为了避免发生意外的错误，以及性能上的考虑，我们不应该在副作用函数与 Symbol.iterator 这类 symbole 值之间建立响应联系，因此需要修改 `get()` 拦截函数：

```js
function createReactive (obj, isShallow = false, isReadonly = false) {
  return new Proxy(obj, {
    // 拦截读取操作
    get (target, key, receiver) {
      // 代理对象可以通过 Symbol.for(RAW) 属性访问原始数据
      if (key === Symbol.for(RAW)) {
        return target
      }
      // 非只读的时候才需要建立响应联系
      // 如果 key 的类型是 symbol，则不进行追踪
      if (!isReadonly && typeof key !== 'symbol') {
        track(target, key)
      }
  
      // 得到原始值结果
      const res = Reflect.get(target, key, receiver)

      // 如果是浅响应，直接返回原始值
      if (isShallow) {
        return res
      }

      if (typeof res === 'object' && res !== null) {
        // 如果数据是只读，则调用 readonly 对值进行包装
        return isReadonly
          ? readonly(res)
          : reactive(res)
      }

      return res
    },
    // ...
  })
}
```

## 数组的查找方法

通过上一节的介绍我们意识到，数组的方法内部其实都依赖了对象的基本语义。所以大多数情况下，我们不需要做特殊处理即可让这些方法按预期工作，例如：

```js
const arr = reactive([1, 2, 3])

effect(() => {
  console.log(arr.includes(1)) // 初始打印 true
})

arr[0] = 3 // 副作用函数重新执行，并打印 false
```

这是因为 includes 方法为了找到给定的值，它内部会访问数组的 length 属性以及数组的索引，因此当我们修改某个索引指向的元素值后能够触发响应。

然而 includes 方法并不是总是按照预期工作的，举个例子：

```js
const obj = {}
const arr = reactive([obj])

console.log(arr.includes(arr[0])) // false
```

上面的代码理应会打印 true，但结果却是个 false。为什么会这样呢？在 ECMA-262 规范的 23.1.3.13 节的第 1 步 指出：

```
1. 让 O 的值为 ? ToObject(this value)。
```

第 10 步的 a 步骤指出：

```
10. 重复，while 循环（条件为 k < len），
	a. 让 elementK 的值为 ? Get(O, ! ToString(F(K))) 的结果
```

这里我们注意第 1 步，这里面的 this 是谁呢？在 arr.includes(arr[0]) 语句中，arr 是代理对象，所以 includes 函数执行时的 this 指向的是代理对象 arr。接着我们看第 10.a 步，可以看到 includes 方法会通过索引读取数组元素的值，但这里的 O 是代理对象 arr。

我们知道，通过代理对象来访问元素值时，如果值仍然是可以被代理的，那么得到的值就是新的代理对象而非原始值。下面这段 `set()` 拦截函数内的代码可以证明这一点：

```js
if (typeof res === 'object' && res !== null) {
	return isReadonly ? readonly(res) : reactive(res)
}
```

知道这些后，我们再回头看这句代码：arr.includes(arr[0])。其中，arr[0] 得到的是一个代理对象，而在 includes 方法内部也会通过 arr 访问数组元素，从而也得到一个代理对象，问题是这两个代理对象是不同的。这是因为每次调用 `reactive()` 函数都会创建一个新的代理对象：

```js
function reactive (obj) {
	return createReactive(obj)
}
```

即使参数 obj 是相同的，每次调用 `reactive()` 函数时，也都会创建新的代理对象。这个问题的解决方案如下：

```js
// 定义一个 Map 实例，用来缓存原始对象到代理对象的映射
const reactiveMap = new Map()

function reactive (obj) {
  // 先通过原始对象 obj 寻找之前创建的代理对象
  const existionProxy = reactiveMap.get(obj)
  // 如果已经代理过的对象，直接返回已有的代理对象
  if (existionProxy) {
    return existionProxy
  }

  // 否则，创建新的代理对象
  const proxy = createReactive(obj)
  // 并把新的代理对象存储到 Map 中，从而避免重复创建
  reactiveMap.set(obj, proxy)

  return proxy
}
```

如此，我们就可以避免为同一个原始对象多次创建不同的代理对象，这也就解决了一开始的问题。

然而，还不能高兴得太早，继续来看下面的代码：

```js
const obj = {}
const arr = reactive([obj])

console.log(arr.includes(obj)) // false
```

这又是为什么呢？其实原因很简单，因为 includes 内部的 this 指向的是代理对象 arr，并且在获取数组元素时得到的值也是代理对象，所以拿原始对象 obj 去查找肯定是找不到的。

为此，我们需要重写数组的 includes 方法并实现自定义的行为，才能解决这个问题：

```js
const arrayInstrumentations = {
  includes () { /* ... */ }
}

function createReactive (obj, isShallow = false, isReadonly = false) {
  return new Proxy(obj, {
    // 拦截读取操作
    get (target, key, receiver) {
      // 代理对象可以通过 Symbol.for(RAW) 属性访问原始数据
      if (key === Symbol.for(RAW)) {
        return target
      }

      // 如果操作的目标对象是数组，并且 key 存在于 arrayInstrumentations 上，
      // 那么返回定义在 arrayInstrumentations 上的值
      if (Array.isArray(target) && arrayInstrumentations.hasOwnProperty(key)) {
        return Reflect.get(arrayInstrumentations, key, receiver)
      }

      // 非只读的时候才需要建立响应联系
      // 如果 key 的类型是 symbol，则不进行追踪
      if (!isReadonly && typeof key !== 'symbol') {
        track(target, key)
      }
  
      // 得到原始值结果
      const res = Reflect.get(target, key, receiver)

      // 如果是浅响应，直接返回原始值
      if (isShallow) {
        return res
      }

      if (typeof res === 'object' && res !== null) {
        // 如果数据是只读，则调用 readonly 对值进行包装
        return isReadonly
          ? readonly(res)
          : reactive(res)
      }

      return res
    },
    // ...
  })
}
```

我们在 `get()` 拦截函数上增加了一个判断：如果操作的目标对象是数组，并且 key 存在 `arrayInstrumentations` 上，那么返回定义在 `arrayInstrumentations` 上的值。也就是说，当执行 `arr.includes()` 时，实际上执行的是定义在 `arrayInstrumentataions` 上的 `includes()` 函数，这样就实现了重写。

接下来我们再看看 `arrayInstrumentations` 上怎么写：

```js
const originMethod = Array.prototype.includes
const arrayInstrumentations = {
  includes (...args) {
    // this 是代理对象，先在代理对象中查找，将结果存到 res 中
    let res = originMethod.apply(this, args)

    if (res === false) {
      // res 为 false 说明没找到
      // 通过 this[Symbol.for(RAW)] 拿到原始数组，再去其中查找并更新 res 的值
      res = originMethod.apply(this[Symbol.for(RAW)], args)
    }

    // 返回最终的结果
    return res
  }
}
```

如此便能解决上述的问题。

除了 `includes()` 方法之外，还需要做类似处理的方法有 `indexOf()`、和 `lastIndexOf()`，它们都属于根据给定的值返回查找结果的方法。完整的代码如下：

```js
const arrayInstrumentations = {}
;['includes', 'indexOf', 'lastIndexOf'].forEach(method => {
  const originMethod = Array.prototype[method]

  arrayInstrumentations[method] = function (...args) {
    // this 是代理对象，先在代理对象中查找，将结果存到 res 中
    let res = originMethod.apply(this, args)

    if (res === false) {
      // res 为 false 说明没找到
      // 通过 this[Symbol.for(RAW)] 拿到原始数组，再去其中查找并更新 res 的值
      res = originMethod.apply(this[Symbol.for(RAW)], args)
    }

    // 返回最终的结果
    return res
  }
})
```

## 隐式修改数组长度的原型方法

数组的栈方法，会隐式修改数组长度，例如 push/pop/unshift/shift。除此之外，splice 方法也会隐式地修改数组长度。

以 push 为例，在 ECMA-262 规范的 23.1.3.20 节的第 2 步 和 第 6 步可知，当调用数组的 push 方法向数组中添加元素时，既会读取数组的 length 属性值，也会设置数组的 length 属性值。这会导致两个独立的副作用函数互相影响：

```js
const arr = reactive([])

// 第一个副作用函数
effect(() => {
  arr.push(1)
})

// 第二个副作用函数
effect(() => {
  arr.push(2)
})
```

我们尝试运行这段代码，会得到栈溢出的错误 Maximum call stack size exceeded。为什么会这样呢？我们详细分析上面这段代码的执行过程：

+ 第一个副作用函数执行。在该函数内，我们给数组中添加了一个元素，我们知道，调用数组的 push 方法会间接读取数组的 length 属性。所以，我们函数执行完毕后，会与 length 属性建立响应联系；
+ 接着，第二个副作用函数执行。同样，它也会与 length 属性建立响应联系。但不要忘记，调用 arr.push 方法不仅会间接读取数组的 length 属性，还会间接设置 length 属性的值；
+ 第二个函数内的 arr.push 方法的调用设置了数组的 length 属性值。于是，响应系统尝试把与 length 属性相关联的副作用函数全部取出并执行，其中就包括第一个副作用函数。问题就在这里，可以发现，第二个副作用函数还未执行完毕，就要再次执行第一个副作用函数了；
+ 第一个副作用函数再次执行。同样会把第二个副作用函数的取出来执行；
+ 如此循环往复，最终导致调用栈溢出。

问题就出现在 push 方法的调用会间接读取 length 属性。所以，只要我们“屏蔽”对 length 属性的读取，从而避免在它与副作用函数之间建立响应联系，问题就迎刃而解了。

这个思路是正确的，因为数组的 push 方法在语义上是设置操作，而非读取操作，所以避免建立联系并不会产生其他副作用。有了这个思路后，我们尝试实现它，这需要重写数组的 push 方法：

```js
// 声明一个标记变量，代表是否进行追踪。默认值为 true，即允许追踪
let shouldTrack = true
// 重写数组的 push 方法
;['push'].forEach(method => {
  const originMethod = Array.prototype[method]

  arrayInstrumentations[method] = function (...args) {
    // 在调用原始方法之前，先禁止追踪
    shouldTrack = false

    let res = originMethod.apply(this, args)

    // 在调用原始方法之后，允许追踪
    shouldTrack = true

    return res
  }
})
```

最后，我们还需要修改 `track()` 函数：

```js
function track (target, key) {
  // 当禁止追踪时，直接返回
  if (!activeEffect || !shouldTrack) return

  // ... 省略其它代码
}
```

如此一来，我们就能解决一开始的问题了。

除了 push 方法之外，pop、unshift、shift 以及 splice 等方法都需要做类似处理。完整的代码如下：

```js
// 声明一个标记变量，代表是否进行追踪。默认值为 true，即允许追踪
let shouldTrack = true
// 重写数组的 'push', 'pop', 'unshift', 'shift', 'splice' 方法
;['push', 'pop', 'unshift', 'shift', 'splice'].forEach(method => {
  const originMethod = Array.prototype[method]

  arrayInstrumentations[method] = function (...args) {
    // 在调用原始方法之前，先禁止追踪
    shouldTrack = false

    let res = originMethod.apply(this, args)

    // 在调用原始方法之后，允许追踪
    shouldTrack = true

    return res
  }
})
```

## 代理 Set 和 Map

从本节开始，我们将介绍集合类型数据的响应式方案。集合类型包括 Map/Set 以及 WeakMap/WeakSet。使用 Proxy 代理集合类型的数据不同于代理普通对象，因为集合类型数据的操作与普通对象存在很大的不同。

下面总结了 Set 和 Map 这两个数据类型的原型属性和方法。

Set 类型的原型属性和方法如下：

+ size: 返回集合中元素的数量；
+ add(value)：向集合中添加给定的值；
+ clear()：清空集合；
+ delete(value)：删除指定的值；
+ has(value)：判断指定的值是否在集合中；
+ keys()：返回一个迭代器对象。迭代器对象产生的值为集合中的元素值；
+ values()：对于 Set 来说，keys() 与 values() 等价；
+ entries()：返回一个迭代器对象。迭代器对象产生的值为：[value, value]；
+ forEach(callback[, thisArg])：遍历集合中的所有元素，并对每一个元素都调用 callback 函数；第二个参数可为选择参数 thisArg，用于指定 callback 执行期上下文 this。

Map 类型的原型属性和方法如下：

+ size: 返回 Map 数据中的键值对的数量；
+ clear()：清空 Map；
+ delete(key)：删除指定 key 的键值对；
+ has(key)：判断 Map 中是否存在指定 key 的键值对；
+ get(key)：读取指定 key 对应的值；
+ set(key, value)：为 Map 设置新的键值对；
+ keys()：返回一个迭代器对象。迭代器对象产生的值为对应的 key 值；
+ values()：返回一个迭代器对象。迭代器对象产生的值为对应的 value 值；
+ entries()：返回一个迭代器对象。迭代器对象产生的值为对应的 [key, value]；
+ forEach(callback[, thisArg])：遍历 Map 数据的所有键值对，并对每一个键值对调用 callback 函数；；第二个参数可为选择参数 thisArg，用于指定 callback 执行期上下文 this。

通过上述列表可以发现，Map 和 Set 这两个数据类型的操作方法很相似。它们之前最大的不同体现在，Set 类型使用 add(value) 方法添加元素，而 Map 类型使用 set(key, value) 方法设置键值对，并且 Map 类型可以使用 get(key) 方法读取相应的值。既然两者如此相似，那么是不是意味着我们可以用相同的处理办法来实现对它们的代理呢？没错，接下来，我们就深入探讨如何实现对 Set 和 Map 类型的代理。

## 如何代理 Set 和 Map

整体思路不变，读取时调用 `track()` 函数建立响应联系；设置时调用 `trigger()` 函数触发响应。例如：

```js
const proxy = reactive(new Map([['key', 1]]))

effect(() => {
  console.log(proxy.get('key')) // 读取键为 key 的值
})

proxy.set('key', 2) // 设置键为 key 的值，应该触发响应
```

这段代码展示了我们最终要实现的目标。但在动手实现之前，我们有必要先了解一下关于使用 Proxy 代理 Set 或 Map 类型数据的注意事项：

```js
const s = new Set([1, 2, 3])
const p = new Proxy(s, {})

console.log(p.size) // Uncaught TypeError: Method get Set.prototype.size called on incompatible receiver #<Set>
```

我们运行上面的代码，得到了一个错误。大意为“在不兼容的 receiver 上调用了 Set.prototype.size 方法”。由此我们大概能猜到，size 属性应该是一个访问器属性，所以它作为方法被调用了。通过查阅规范可以证实这一点，在第 24.2.3.9 节中指出：Set.prototype.size 是一个访问器属性，它的第 1 步描述：让 S 的值为 this，这里的 this 在我们的例子中是 p；接着第 2 步中，调用抽象方法 RequireInternalSlot(S, [[SetData]]) 来检查 S 是否存在内部槽 `[[SetData]]`。很显然，代理对象上不存在这个内部槽，于是会抛出错误。

为了修复这个问题，我们需要修正访问器属性的 `getter()` 函数执行时的 this 指向：

```js
const s = new Set([1, 2, 3])
const p = new Proxy(s, {
  get (target, key, receiver) {
    if (key === 'size') {
      // 如果读取的是 size 属性，
      // 指定 receiver 为原始对象 target
      return Reflect.get(target, key, target)
    }

    return Reflect.get(target, key, receiver)
  }
})

console.log(p.size) // 3
```

如此，这个案例就可以正确运行了。

接着，我们再来尝试一下从 Set 中删除数据：

```js
const s = new Set([1, 2, 3])
const p = new Proxy(s, {
  get (target, key, receiver) {
    if (key === 'size') {
      // 如果读取的是 size 属性，
      // 指定 receiver 为原始对象 target
      return Reflect.get(target, key, target)
    }

    return Reflect.get(target, key, receiver)
  }
})

p.delete(1) // Uncaught TypeError: Method Set.prototype.delete called on incompatible receiver #<Set>
```

这个错误和之前访问 p.size 属性时发生的错误非常相似。我们分析一下调用 p.delete(1) 方法时发生了什么。

实际上，访问 p.size 与 p.delete 是不同的。这是因为 size 是一个访问器属性，而 delete 是一个方法。当访问 p.size 时，访问器属性的 getter 函数会立即执行，此时我们可以通过修改 receiver 来改变 getter 函数的 this 指向。而当访问 p.delete 时，delete 方法并没有执行，真正使其执行的语句是 p.delete(1) 这句函数调用。因此无论怎么修改 receiver，`delete()` 方法执行时的 this 都会指向代理对象 p，而不会指向原始对象 s。

想要修复这个问题，只需要把 delete 方法与原始对象绑定即可：

```js
const s = new Set([1, 2, 3])
const p = new Proxy(s, {
  get (target, key, receiver) {
    if (key === 'size') {
      // 如果读取的是 size 属性，
      // 指定 receiver 为原始对象 target
      return Reflect.get(target, key, target)
    }

    // 将方法与原始数据对象 target 绑定后返回
    return target[key].bind(target)
  }
})

p.delete(1)
```

最后，我们把代码封装到之前的 `createReactive()` 函数中：

```js
// 定义一个 Set 集合，存储所有集合类型字符串
// 用于判断 target 的类型
const COLLECTION_TYPE = new Set([
  '[object Map]',
  '[object Set]',
  '[object WeakMap]',
  '[object WeakSet]'
])

function createReactive (obj, isShallow = false, isReadonly = false) {
  return new Proxy(obj, {
    // 拦截读取操作
    get (target, key, receiver) {
      // 集合类型有不同的处理方案
      if (COLLECTION_TYPE.has(Object.prototype.toString.call(target))) {
        if (key === 'size') {
          // 如果读取的是 size 属性，
          // 指定 receiver 为原始对象 target
          return Reflect.get(target, key, target)
        }

        // 将方法与原始数据对象 target 绑定后返回
        return target[key].bind(target)
      }
      // ... 省略之前封装的代码
    }
  })
}
```

## 建立响应联系

我们开始着手实现 Set 类型的响应式方案，思路并不复杂，以下面的代码为例：

```js
const p = reactive(new Set([1, 2, 3]))

effect(() => {
  console.log(p.size)
})

p.add(1)
```

为了实现这个目标，我们需要在访问 size 属性时调用 `track()` 函数进行依赖追踪，然后在 `add()` 方法执行时调用 `trigger()` 函数触发响应：

```js
function createReactive (obj, isShallow = false, isReadonly = false) {
  return new Proxy(obj, {
    // 拦截读取操作
    get (target, key, receiver) {
      // 集合类型有不同的处理方案
      if (COLLECTION_TYPE.has(Object.prototype.toString.call(target))) {
        if (key === 'size') {
          // 调用 track() 函数进行依赖追踪
          track(target, ITERATE_KEY)
          // 如果读取的是 size 属性，
          // 指定 receiver 为原始对象 target
          return Reflect.get(target, key, target)
        }

        // 将方法与原始数据对象 target 绑定后返回
        return target[key].bind(target)
      }
      // ...
    },
    // ...
  })
}
```

那么，当调用 `add()` 方法时，应该如何触发响应呢？很显然，这需要我们实现一个自定义的 `add()` 方法才行：

```js
// 声明一个对象，将自定义的 add 方法定义到该对象下
const mutableInstrumentations = {
  add (key) { /* ... */ }
}
function createReactive (obj, isShallow = false, isReadonly = false) {
  return new Proxy(obj, {
    // 拦截读取操作
    get (target, key, receiver) {
      // 集合类型有不同的处理方案
      if (COLLECTION_TYPE.has(Object.prototype.toString.call(target))) {
        // 如果读取的是 Symbol.for(RAW) 属性，则返回原始数据对象 target
        if (key === Symbol.for(RAW)) {
          return target
        }

        if (key === 'size') {
          // 调用 track() 函数进行依赖追踪
          track(target, ITERATE_KEY)
          // 如果读取的是 size 属性，
          // 指定 receiver 为原始对象 target
          return Reflect.get(target, key, target)
        }

        // 返回定义在 mutableInstrumentations 对象下的方法
        return mutableInstrumentations[key]
      }
      // ...
    },
    // ...
  })
}
```

那么我们看下 `mutableInstrumentations.add` 的定义：

```js
// 声明一个对象，将自定义的 add 方法定义到该对象下
const mutableInstrumentations = {
  add (key) {
    const target = this[Symbol.for(RAW)]

    // 因为 target 是原始对象，所以不再需要 bind
    const res = target.add(key)

    // 调用 trigger() 函数触发响应，并指定操作类型为 ADD
    trigger(target, key, TriggerType.ADD)

    return res
  }
}
```

这里我们就完成了响应式的处理，当然，如果调用 `add()` 添加的元素已经存在于 Set 集合中，就不需要再触发响应了，这样做对性能更加友好，因此，我们可以对代码做以下优化：

```js
// 声明一个对象，将自定义的 add 方法定义到该对象下
const mutableInstrumentations = {
  add (key) {
    const target = this[Symbol.for(RAW)]
    let res

    // 先判断是否存在该值
    const hadKey = target.has(key)

    // 只有不存在的情况下，才需要触发响应
    if (!hadKey) {
      // 因为 target 是原始对象，所以不再需要 bind
      res = target.add(key)
  
      // 调用 trigger() 函数触发响应，并指定操作类型为 ADD
      trigger(target, key, TriggerType.ADD)
    }

    return res
  }
}
```

在此基础上，我们可以按照类似的思路实现 delete 方法：

```js
const mutableInstrumentations = {
  delete (key) {
    const target = this[Symbol.for(RAW)]

    // 先判断是否存在该值
    const hadKey = target.has(key)
    
    const res = target.delete(key)

    // 只有该值存在的情况下，才需要触发响应
    if (hadKey) {
      // 调用 trigger() 函数触发响应，并指定操作类型为 DELETE
      trigger(target, key, TriggerType.DELETE)
    }

    return res
  }
}
```

## 避免污染原始数据

我们借助 Map 类型数据的 set 和 get 这两个方法来讲解什么是“避免污染原始数据”及其原因。

```js
const p = reactive(new Map([['key', 1]]))

effect(() => {
  console.log(p.get('key'))
})

p.set('key', 2)
```

其实想要实现上面的功能并不难，因为我们已经有了实现 add、delete 方法的经验。下面是 get 方法的实现：

```js
const mutableInstrumentations = {
  get (key) {
    const target = this[Symbol.for(RAW)]

    // 先判断读取的 key 是否存在
    const had = target.has(key)

    // 追踪依赖
    track(target, key)

    // 如果存在，则返回结果
    if (had) {
    	const res = target.get(key)
      // 如果值仍然是一个可代理的数据，则返回使用 reactive() 包装的响应式数据
      return typeof res === 'object' && res !== null
        ? reactive(res)
        : res
    }
  },
  // ...
}
```

接下来，我们讨论一下 set 方法的实现，当 set 方法被调用时，需要调用 `trigger()` 函数触发响应。只不过在响应的时候，需要区分操作的类型是 SET 还是 ADD：

```js
const mutableInstrumentations = {
  set (key, value) {
    const target = this[Symbol.for(RAW)]

    const had = target.has(key)

    // 获取旧值
    const oldVal = target.get(key)
    // 设置新值
    target.set(key, value)

    // 如果不存在，说明是 ADD 操作
    if (!had) {
      trigger(target, key, TriggerType.ADD)
    } else if (oldVal !== value || (oldVal === oldVal && value === value)) {
      // 如果不存在，并且值变了，则是 SET 类型的操作
      trigger(target, key, TriggerType.SET)
    }
  },
  // ...
}
```

上面给出的代码能够正常工作，但它仍然存在问题，即 set 方法会污染原始数据。什么意思呢？我们看下面的代码：

```js
// 原始数据 m
const m = new Map()
// p1 是 m 的代理对象
const p1 = reactive(m)
// p2 是另一个代理对象
const p2 = reactive(new Map())

// 为 p1 设置一个键值对，值是代理对象 p2
p1.set('p2', p2)

effect(() => {
  // 注意，这里我们通过原始数据 m 来访问 p2
  console.log(m.get('p2').size)
})

// 注意，这里我们通过原始数据 m 为 p2 设置一个键值对
m.get('p2').set('foo', 1)
```

运行上面的代码，发现副作用函数重新执行了。这意味着原始用户可以操作原始数据，又能够操作响应式数据，这不是我们所期望的行为。

那么导致问题的原因是什么呢？其实很简单，观察我们前面实现的 set 方法：

```js
const mutableInstrumentations = {
  set (key, value) {
    const target = this[Symbol.for(RAW)]

    const had = target.has(key)

    // 获取旧值
    const oldVal = target.get(key)
    // 设置新值
    target.set(key, value)

    // 如果不存在，说明是 ADD 操作
    if (!had) {
      trigger(target, key, TriggerType.ADD)
    } else if (oldVal !== value || (oldVal === oldVal && value === value)) {
      // 如果不存在，并且值变了，则是 SET 类型的操作
      trigger(target, key, TriggerType.SET)
    }
  },
  // ...
}
```

在 set 方法的内部，我们把 value 原封不动地设置到了原始数据 target 上。如果 value 是响应式数据，就意味着设置到原始对象上的也是响应式数据，我们把**响应式数据设置到原始数据上的行为称为数据污染。**

解决办法也很简单，我们只需要在给原始对象上设置数据时，如果该值是一个响应式数据，则使用他的 Symbol.for(RAW) 里面存储的原始对象即可：

```js
const mutableInstrumentations = {
  set (key, value) {
    const target = this[Symbol.for(RAW)]

    const had = target.has(key)

    // 获取旧值
    const oldVal = target.get(key)
    // 如果存在 value[Symbol.for(RAW)] 则设置为 value[Symbol.for(RAW)] 的值
    // 否则说明 value 是一个原始数据，设置 value 即可
    const rawValue = value[Symbol.for(RAW)] || value
    // 设置新值
    target.set(key, rawValue)

    // 如果不存在，说明是 ADD 操作
    if (!had) {
      trigger(target, key, TriggerType.ADD)
    } else if (oldVal !== value || (oldVal === oldVal && value === value)) {
      // 如果不存在，并且值变了，则是 SET 类型的操作
      trigger(target, key, TriggerType.SET)
    }
  },
  // ...
}
```

## 处理 forEach

集合类型的 forEach 方法类似于数组的 forEach 方法，我们先来看看它是如何工作的：

```js
const m = new Map([
  [{key: 1}, { value: 1 }]
])

effect(() => {
  m.forEach((value, key, m) => {
    console.log(value) // { value: 1 }
    console.log(key) // { key: 1 }
  })
})
```

如上面的代码所示，我们可以使用 forEach 方法遍历 Map 数据的每一组键值对。

遍历的操作只与键值对的数量有关，因此任何会修改 Map 对象键值对数量的操作都应该触发副作用函数重新执行，例如 set 和 delete 方法。所以当 forEach 函数被调用时，我们应该让副作用函数与 ITERATE_KEY 建立响应联系：

```js
const mutableInstrumentations = {
  forEach (callback) {
    const target = this[Symbol.for(RAW)]
    // 与 ITERATE_KEY 建立响应联系
    track(target, ITERATE_KEY)
    // 通过原始数据对象调用 forEach 方法，并把 callback 传递过去
    target.forEach(callback)
  },
  // ...
}
```

这就实现对 forEach 操作的追踪，可以使用下面的代码来测试：

```js
const p = reactive(new Map([
  [{key: 1}, { value: 1 }]
]))

effect(() => {
  p.forEach((value, key, m) => {
    console.log(value) // { value: 1 }
    console.log(key) // { key: 1 }
  })
})

p.set({key: 2}, { value: 2 }) // 能够触发响应
```

然后，我们给出的 forEach 函数还是有缺陷的，我们在自定义实现的 forEach 方法内，通过原始数据对象调用了原生的 forEach 方法，即

```js
target.forEach(callback)
```

这意味着，传递给 callback 回调函数的参数将是非响应式数据的。所以我们需要做一些修改：

```js
const mutableInstrumentations = {
  forEach (callback) {
    // wrap 函数用来把可以代理的值转换为响应式数据
    const wrap = val => typeof val === 'object' ? reactive(val) : val
    const target = this[Symbol.for(RAW)]
    // 与 ITERATE_KEY 建立响应联系
    track(target, ITERATE_KEY)
    // 通过原始数据对象调用 forEach 方法，并把 callback 传递过去
    target.forEach((v, k) => {
      // 手动调用 callback，用 wrap 函数包裹 value 和 key 后再传递给 callback
      // 这样就实现了深响应
      callback(wrap(v), wrap(k), this)
    })
  },
  // ...
}
```

最后，出于严谨性，我们还需要做一些补充。因为 forEach 函数还可以接收一个可选的 thisArg 参数：

```js
const mutableInstrumentations = {
  forEach (callback, thisArg) {
    // wrap 函数用来把可以代理的值转换为响应式数据
    const wrap = val => typeof val === 'object' ? reactive(val) : val
    const target = this[Symbol.for(RAW)]
    // 与 ITERATE_KEY 建立响应联系
    track(target, ITERATE_KEY)
    // 通过原始数据对象调用 forEach 方法，并把 callback 传递过去
    target.forEach((v, k) => {
      // 手动调用 callback，用 wrap 函数包裹 value 和 key 后再传递给 callback
      // 这样就实现了深响应
      // 通过 call 调用，并传递 thisArg
      callback.call(thisArg, wrap(v), wrap(k), this)
    })
  },
  // ...
}
```

至此，我们的工作仍然没有完成。我们知道，无论是使用 for...in 循环遍历一个对象，还是使用 forEach 循环遍历一个集合，它们的响应联系都是建立在 ITERATE_KEY 与副作用函数之间的。然而，使用 for...in 来遍历对象与使用 forEach 遍历集合之间存在本质的不同。具体体现在：当使用 for...in 循环遍历对象时，它只关心对象的键，而不关心对象的值，如以下代码所示：

```js
effect(() => {
  for (const key in obj) {
		console.log(key)
  }
})
```

只有当新增、删除对象的 key 时，才需要重新执行副作用函数。所以我们在 `trigger()` 函数内判断操作类型是否是 ADD 或 DELETE，进而知道是否需要触发那些与 ITERATE_KEY 相关联的副作用函数重新执行。对于 SET 类型的操作来说，因为它不会改变一个对象的键的数据，所以当 SET 类型的操作发生时，不需要触发副作用函数重新执行。

然而这个规则不适用于 Map 类型的 forEach 遍历，如以下代码所示：

```js
const p = reactive(new Map([
  ['key', 1]
]))

effect(() => {
  p.forEach((value, key) => {
    // forEach 不仅关心 key，还关心 value
    console.log(value) // 1
  })
})

p.set('key', 2) // 即使操作类型是 SET,也应该触发响应
```

所以我们需要修改 `trigger()` 函数来弥补这一缺陷：

```js
function trigger (target, key, type, newVal) {
  // ...

  // 只有当操作类型为 'ADD' 或 'DELETE' 时，才触发与 ITERATE_KEY 相关联的副作用函数重新执行
  if (
    type === TriggerType.ADD ||
    type === TriggerType.DELETE ||
    // 如果操作类型是 SET，并且数据类型是 Map
    // 也应该触发那些与 ITERATE_KEY 相联系的副作用函数重新执行
    (
      type === TriggerType.SET &&
      Object.prototype.toString.call(target) === '[object Map]'
    )
  ) {
    iterateEffects && iterateEffects.forEach(effectFn => {
      // 如果 trigger 触发执行副作用函数与当前正在执行的副作用函数相同，则不触发
      if (effectFn !== activeEffect) {
        effectsToRun.add(effectFn)
      }
    })
  }

  // ...
}
```

## 迭代器方法

接下来，我们讨论关于集合类型的迭代器方法，实际上前面讲解如何拦截 for...of 循环遍历数据的时候介绍过迭代器的相关知识。

集合类型有三个迭代器方法：

+ entries()
+ keys()
+ values()

调用这些方法会得到相应的迭代器，并且可以使用 for...of 进行循环迭代。

另外，由于 Map 或 Set 类型本身也部署了 Symbol.iterator 方法，因此它们可以使用 for...of 进行迭代。

```js
const m = new Map([
  ['key1', 'value1'],
  ['key2', 'value2']
])

console.log(m[Symbol.iterator] === m.entries) // true
```

理解了这些内容后，我们就可以尝试实现对迭代器方法的代理了。

实际上，当我们使用 for...of 循环迭代一个代理对象时，内部会试图从代理对象上读取 `[Symbol.iterator]` 这个属性，这个操作会触发 `get()` 拦截函数，所以我们可以把 `Symbol.iterator` 方法的实现放到 mutableIntrumentations 中：

```js
const mutableInstrumentations = {
  [Symbol.iterator] () {
    const target = this[Symbol.for(RAW)]

    // 获取原始迭代器方法
    const itr = target[Symbol.iterator]()

    return itr
  },
  // ...
}
```

然而事情不可能这么简单，在之前我们讲解 forEach 时提到过，传递给 callback 的参数是包装后的响应式数据。同理这里也应该产生包装后的数据：

```js
const mutableInstrumentations = {
  [Symbol.iterator] () {
    const target = this[Symbol.for(RAW)]

    // 获取原始迭代器方法
    const itr = target[Symbol.iterator]()

    const wrap = val => typeof val === 'object' && val !== null
      ? reactive(val)
      : val

    // 返回自定义的迭代器
    return {
      next () {
        const { value, done } = itr.next()

        return {
          // 如果 value 不是 undefined 则对其进行包裹
          value: value ? [wrap(value[0]), wrap(value[1])] : value,
          done
        }
      }
    }
  },
  // ...
}
```

最后，为了追踪 for...of 对数据的迭代操作，我们还需要调用 `track()` 函数进行追踪：

```js
const mutableInstrumentations = {
  [Symbol.iterator] () {
    const target = this[Symbol.for(RAW)]

    // 获取原始迭代器方法
    const itr = target[Symbol.iterator]()

    const wrap = val => typeof val === 'object' && val !== null
      ? reactive(val)
      : val

    // 调用 track() 函数建立响应联系
    track(target, ITERATE_KEY)

    // 返回自定义的迭代器
    return {
      next () {
        const { value, done } = itr.next()

        return {
          // 如果 value 不是 undefined 则对其进行包裹
          value: value ? [wrap(value[0]), wrap(value[1])] : value,
          done
        }
      }
    }
  },
  // ...
}
```

我们使用以下代码来测试一下：

```js
const p = reactive(new Map([
  ['key1', 'value1'],
  ['key2', 'value2']
]))

effect(() => {
  for (const [key, value] of p) {
    console.log(key, value)
  }
})

p.set('key3', 'value3') // 能够触发响应
```

前面我们说过，p.entries 与 p[Symbol.iterator] 是等价的，因此我们可以使用相同的方法来实现对 p.entries 函数的拦截：

```js
const mutableInstrumentations = {
  [Symbol.iterator]: iterationMethod,

  entries: iterationMethod,
  
  // ...
}

// 抽离为独立函数，方便复用
function iterationMethod () {
  const target = this[Symbol.for(RAW)]

  // 获取原始迭代器方法
  const itr = target[Symbol.iterator]()

  const wrap = val => typeof val === 'object' && val !== null
    ? reactive(val)
    : val

  // 调用 track() 函数建立响应联系
  track(target, ITERATE_KEY)

  // 返回自定义的迭代器
  return {
    next () {
      const { value, done } = itr.next()

      return {
        // 如果 value 不是 undefined 则对其进行包裹
        value: value ? [wrap(value[0]), wrap(value[1])] : value,
        done
      }
    }
  }
}
```

但当你尝试运行下面的代码时，会得到一个错误：

```js
const p = reactive(new Map([
  ['key1', 'value1'],
  ['key2', 'value2']
]))

effect(() => {
  for (const [key, value] of p.entries()) {
    console.log(key, value)
  }
})

p.set('key3', 'value3')
// Uncaught TypeError: p.entries is not a function or its return value is not iterable
```

意思是 p.entries 的返回值不是一个可迭代的对象。这里是经常出错的地方，大家切勿把可迭代协议和迭代器协议搞混。

**可迭代协议**指的是一个对象实现了 Symbol.iterator 方法，而**迭代器协议**指的是一个对象实现了 next 对象。

一个对象可以同时实现可迭代协议和迭代器协议。所以解决问题的方法也自然而然地出现了：

```js
function iterationMethod () {
  const target = this[Symbol.for(RAW)]

  // 获取原始迭代器方法
  const itr = target[Symbol.iterator]()

  const wrap = val => typeof val === 'object' && val !== null
    ? reactive(val)
    : val

  // 调用 track() 函数建立响应联系
  track(target, ITERATE_KEY)

  // 返回自定义的迭代器
  return {
    next () {
      const { value, done } = itr.next()

      return {
        // 如果 value 不是 undefined 则对其进行包裹
        value: value ? [wrap(value[0]), wrap(value[1])] : value,
        done
      }
    },

    // 实现可迭代协议
    [Symbol.iterator] () {
      return this
    }
  }
}
```

## values 与 keys 方法

values 方法的实现与 entries 方法类似，不同的时，当使用 for...of 迭代 values 时，得到的仅仅是 Map 数据是值，而非键值对：

```js
const mutableInstrumentations = {
  values: valuesIterationMethod,
  // ...
}

function valuesIterationMethod () {
  const target = this[Symbol.for(RAW)]

  // 通过 target.values 获取原始迭代器方法
  const itr = target.values()

  const wrap = val => typeof val === 'object' && val !== null
    ? reactive(val)
    : val

  // 调用 track() 函数建立响应联系
  track(target, ITERATE_KEY)

  // 返回自定义的迭代器
  return {
    next () {
      const { value, done } = itr.next()

      return {
        // value 是值，而非键值对，所以只需要包裹 value 即可
        value: wrap(value),
        done
      }
    },

    // 实现可迭代协议
    [Symbol.iterator] () {
      return this
    }
  }
}
```

而 keys 方法与 values 方法非常类型，不同点在于，前者处理的是键而非值。

```js
const mutableInstrumentations = {
  values: valuesIterationMethod,
  // ...
}

function valuesIterationMethod () {
  const target = this[Symbol.for(RAW)]

  // 通过 target.keys 获取原始迭代器方法
  const itr = target.keys()

  const wrap = val => typeof val === 'object' && val !== null
    ? reactive(val)
    : val

  // 调用 track() 函数建立响应联系
  track(target, ITERATE_KEY)

  // 返回自定义的迭代器
  return {
    next () {
      const { value, done } = itr.next()

      return {
        // value 是值，而非键值对，所以只需要包裹 value 即可
        value: wrap(value),
        done
      }
    },

    // 实现可迭代协议
    [Symbol.iterator] () {
      return this
    }
  }
}
```

这样做的确能够达到目的，但如果我们尝试运行以下测试用例，就会发现存在缺陷：

```js
const p = reactive(new Map([
  ['key1', 'value1'],
  ['key2', 'value2']
]))

effect(() => {
  for (const value of p.keys()) {
    console.log(value)
  }
})

p.set('key2', 'value3') // 这是一个 SET 的类型，它修改了 key2 的值
```

我们会发现，副作用函数仍然重新执行了。

这是因为我们对 Map 类型的数据进行了特殊处理。前文提到，即使操作类型为 SET，也会触发那些与 ITERATE_KEY 相关联的副作用函数重新执行。

这对于 values 或 entries 等方法来说是必需的，但对于 keys 方法来说则没有必要，因为 keys 方法只关心 Map 类型数据的键的变化，而不关心值的变化。

因此我们需要修改一下代码：

```js
const MAP_KEY_ITERATE_KEY = Symbol()

function keysIterationMethod () {
  const target = this[Symbol.for(RAW)]

  // 通过 target.keys 获取原始迭代器方法
  const itr = target.keys()

  const wrap = val => typeof val === 'object' && val !== null
    ? reactive(val)
    : val

  // 调用 track() 函数建立副作用函数与 MAP_KEY_ITERATE_KEY 的响应联系
  track(target, MAP_KEY_ITERATE_KEY)

  // 返回自定义的迭代器
  return {
    next () {
      const { value, done } = itr.next()

      return {
        // value 是值，而非键值对，所以只需要包裹 value 即可
        value: wrap(value),
        done
      }
    },

    // 实现可迭代协议
    [Symbol.iterator] () {
      return this
    }
  }
}
```

我们使用一个新的抽象键 MAP_KEY_ITERATE_KEY 来实现依赖收集的分离，即 values 和 entries 等方法仍然使用 ITERATE_KEY，而 keys 方法使用 MAP_KEY_ITERATE_KEY。那么  SET 类型的操作只会触发与 ITERATE_KEY 相关联的副作用函数重新执行时，自然就会忽略那些与 MAP_KEY_ITERATE_KEY 相关联的副作用函数。但当 ADD 和 DELETE 操作发生时，除了需要触发与 ITERATE_KEY 相关联的副作用函数重新执行，还需要触发与MAP_KEY_ITERATE_KEY 相关联的副作用函数重新执行。

所以我们需要修改一下 `trigger()` 函数的代码：

```js
function trigger (target, key, type, newVal) {
  // ...

  // 操作类型为 ADD 或 DELETE
  // 则是 Map 类型的数据
  if (
    (type === TriggerType.ADD || type === TriggerType.DELETE) &&
    Object.prototype.toString.call(target) === '[object Map]'
  ) {
    // 取出那些与 MAP_KEY_ITERATE_KEY 相关联的副作用函数并执行
    const iterateEffects = depsMap.get(MAP_KEY_ITERATE_KEY)
    iterateEffects && iterateEffects.forEach(effectFn => {
      // 如果 trigger 触发执行副作用函数与当前正在执行的副作用函数相同，则不触发
      if (effectFn !== activeEffect) {
        effectsToRun.add(effectFn)
      }
    })
  }

  // ...
}
```

如此，就能够避免不必要的更新了。

至此，我们的非原始值的响应式方案就已经介绍完毕了。

## 🚀 章节链接

- 上一章：[框架设计的核心要素](https://github.com/humandetail/VueJS-design-and-implementation/blob/master/notes/1.%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%A0%B8%E5%BF%83%E8%A6%81%E7%B4%A0.md)

- 下一章: [原始值的响应式方案](https://github.com/humandetail/VueJS-design-and-implementation/blob/master/notes/5.%E5%8E%9F%E5%A7%8B%E5%80%BC%E7%9A%84%E5%93%8D%E5%BA%94%E6%96%B9%E6%A1%88.md)